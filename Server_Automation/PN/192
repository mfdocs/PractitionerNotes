<p><tt>FolderService</tt>&nbsp;provides access to the folders that appear in the Software Library of the SAS Client. Folders enable users to organize software resources into a hierarchical structure and to define security permissions that control access to the contents of folders. Folders can contain packages, software policies, OS sequences, and subfolders. A subfolder does not inherit the contents or properties of its parent.</p>

<p>&nbsp;</p>

<h2>Walking the folder structure</h2>

<p>Walking a folder structure is common operation so much so we'll define a helper function, a generator, to do this based on the semantics of the python&nbsp;<tt>os.walk</tt>&nbsp;function.</p>

<p>folder.py</p>

<pre>from pytwist.com.opsware.folder import FolderRef

def walk(ts, path):
    pathref = ts.folder.FolderService.getFNode(path)
    children = ts.folder.FolderService.getChildren(pathref)

    sub_folders = [x for x in children if isinstance(x,FolderRef)]
    child_objs = [x for x in children if not isinstance(x,FolderRef)]
    yield '/'.join(path), sub_folders, child_objs

    for s in sub_folders:
        for i in walk(ts, path+[s.name]):
            yield i
</pre>

<p>&nbsp;</p>

<h2>Counting items in a folder structure</h2>

<p>To demonstrate the convenience of using the folder.walk function:</p>

<p>countFolderObjects.py</p>

<pre>from folder import walk
from pytwist import twistserver
ts = twistserver.TwistServer()
path = 'Opsware/Tools/Agent Support'
for dirname, subdirList, objectList in walk(ts, path.split('/')):
    print "%s : (sub-folders: %s, items: %s)" % (dirname, len(subdirList), len(objectList))
</pre>

<p>Execution:</p>

<pre>[root@dc1 FolderService]# ./countFolderObjects.py
Opsware/Tools/Agent Support : (sub-folders: 4, items: 1)
Opsware/Tools/Agent Support/yum : (sub-folders: 0, items: 42)
Opsware/Tools/Agent Support/SLES : (sub-folders: 0, items: 2)
Opsware/Tools/Agent Support/Java : (sub-folders: 0, items: 7)
Opsware/Tools/Agent Support/Post-Install Customization : (sub-folders: 0, items: 1)</pre>

<p>&nbsp;</p>

<h2>Locating specific items in a folder structure</h2>

<p>This example walks down from a root folder locating all folders that contain a software policy printing out a full folder path and a comma separated list of software policies by name found in that folder.</p>

<p>findSoftwarePolicies.py</p>

<pre>from folder import walk
from pytwist import twistserver
from pytwist.com.opsware.swmgmt import SoftwarePolicyRef

ts = twistserver.TwistServer()
path = 'Opsware/Tools'
for dirname, _, objectList in walk(ts, path.split('/')):
    found=[obj.name
           for obj in objectList
           if isinstance(obj,SoftwarePolicyRef)]
    if found:
        print dirname, ':', ','.join(found)
</pre>

<p>Execution output</p>

<pre>[root@dc1 FolderService]# ./findSoftwarePolicies.py
Opsware/Tools/Extensible Discovery/Customer Provided Components : Customer Provided Scripts
Opsware/Tools/Extensible Discovery/HP Provided Components : HP Provided Scripts
Opsware/Tools/Ocli : Ocli
Opsware/Tools/Solaris Patching : Solaris IPS Package Acquisition Tools
Opsware/Tools/Server Modules/com.opsware.sitemap.extension.iis : Internet Information Server
Opsware/Tools/Server Modules/com.opsware.server.module.users_groups_windows : Windows Users And Groups
Opsware/Tools/Server Modules/com.opsware.server.module.patches_packages : Registered Software
Opsware/Tools/Server Modules/com.opsware.server.module.users_groups_unix : UNIX Users And Groups
Opsware/Tools/Server Modules/com.opsware.server.module.extensible_discovery : Extensible Discovery
Opsware/Tools/Server Modules/com.opsware.server.module.iis7_windows : Windows IIS Settings
Opsware/Tools/Server Modules/com.opsware.server.module.dot_net_assemblies : Windows .NET Framework Configurations
Opsware/Tools/Server Modules/com.opsware.server.module.local_security : Windows Local Security Settings
Opsware/Tools/Server Modules/com.opsware.server.module.device_manager : Windows Device Manager
Opsware/Tools/Server Modules/com.opsware.server.module.storage.compliance : Storage Compliance Checks
Opsware/Tools/Server Modules/com.opsware.server.module.storage.dbscanner.oracle : Database scanner for Oracle
Opsware/Tools/Server Modules/com.opsware.testing.sleep : Sleep 60s SMO
Opsware/Tools/Server Modules/com.opsware.sitemap : Runtime State
Opsware/Tools/Server Modules/com.opsware.sitemap.extension.weblogic : Weblogic
Opsware/Tools/Server Module Utility : Server Module Utility
Opsware/Tools/ISMtool : ISMtool
Opsware/Tools/Python : Python for SA Modules
Opsware/Tools/Chef-12.8.1 : chef-solo-12.8.1
Opsware/Tools/Python 2 Opsware API Access for Server Modules : Python 2 Opsware API Access for Server Modules
Opsware/Tools/Python Opsware API Access : Python Opsware API Access
Opsware/Tools/Windows PowerShell Connector : Windows PowerShell Connector
Opsware/Tools/Database &amp; Middleware Automation : DMA Agent Support</pre>

<p>There is a faster way to perform this same operation by using the class matching&nbsp;<tt>list()</tt>&nbsp;method.</p>

<pre>#!/opt/opsware/bin/python
from pytwist import twistserver
ts = twistserver.TwistServer()
FS = ts.folder.FolderService

pathRef = FS.getFNode(['Opsware','Tools'])
fNodeRefs = FS.list(pathRef,True,'com.opsware.swmgmt.SoftwarePolicyRef')
for fnode in fNodeRefs:
    print '/'.join(f.name for f in fnode if f.id != 0)
</pre>

<p>This takes 1sec and using the walk took 17sec - why is this? The&nbsp;<tt>list</tt>&nbsp;method recursively iterates the folder structure and pattern matches inside the Twist removing all the PyTwist calling overhead.</p>

<p>The&nbsp;<tt>list</tt>&nbsp;call returns an array of tuples each tuple will look like the below. The join generator skips folderRef 0, the root node, when reassembling the path to the software policy.</p>

<pre>(&lt;/ (FolderRef:0) instance at 0x7f7189259098&gt;, &lt;Opsware (FolderRef:10001) instance at 0x7f71892590e0&gt;, &lt;Tools (FolderRef:80001) instance at 0x7f7189259128&gt;, &lt;Server Modules (FolderRef:280001) instance at 0x7f7189259170&gt;, &lt;com.opsware.server.module.device_manager (FolderRef:2000001) instance at 0x7f7189259a70&gt;, &lt;Windows Device Manager (SoftwarePolicyRef:410001) instance at 0x7f7189259ab8&gt;
)</pre>

<p>A simple change to print out the folder structure instead.</p>

<pre>fNodeRefs = FS.list(pathRef,True,'com.opsware.folder.FolderRef')
</pre>

<p><tt>list</tt>&nbsp;without supplying any class matching string is equivalent to the&nbsp;<tt>walk</tt>&nbsp;function with the downside that the entire result set must be computed and returned from the call as its not a generator function. This call should not be abused for large sub-tree traversals.</p>

<p>&nbsp;</p>

<h2>Creating/Removing folder structures</h2>

<p>In this example we will replicate the following filesystem hierarchy into the SA folder structure</p>

<pre>root
├── a
│   ├── b
│   │   └── c
│   └── d
└── e</pre>

<p>First create the structure above</p>

<pre>mkdir -p root/a/b/c
mkdir root/a/d
mkdir root/e</pre>

<p>Map the structure into SA</p>

<pre>import os
from pytwist import twistserver

ts = twistserver.TwistServer()
FolderService = ts.folder.FolderService

saRoot = FolderService.getRoot()
for dirpath, _, _ in os.walk("root", topdown=True):
    FolderService.createPath(saRoot, dirpath.split('/'))
</pre>

<p>On execution the OS file system structure we created will be replicated in the SA library. What's more the code can be ran again as the&nbsp;<tt>createPath()</tt>&nbsp;call is indifferent to the fact that directories may already be present and it will only create what is missing.</p>

<p><img src="./mediawiki/images/PN/root-folders.png"></p>

<p>&nbsp;</p>

<p>The removal of that structure is accomplish by a call to&nbsp;<tt>bulkRemove</tt>&nbsp;that will recursively delete all children below our root folder. Be careful with this call a misstep will delete the folder and its contents if you have permissions to do so.</p>

<p>&nbsp;</p>

<pre>fnode = ts.folder.FolderService.getFNode(['root'])
ts.folder.FolderService.bulkRemove([fnode])</pre>
