<p>Business Value Dashboards present your data in real time in a very flexible layout for visualizing on any browser capable device.&nbsp; Within Micro Focus Network Operations Management (NOM) suite, there are several out-of-the-box data sources, such as incidents from Network Node Manager (NNMi) and device configuration and vulnerability from Network Automation (NA).&nbsp; These data sources can be streamed to BVD when integration is enabled.&nbsp;&nbsp; However, the current NOM Suite by default does not include an out-of-the-box performance metrics data source for BVD.&nbsp; This article will demonstrate how to build a new data channel solution to achieve this requirement with a concrete use case.</p>

<p><strong>Use Case Description</strong>:&nbsp; Due to the COVID-19 outbreak, Company A is requesting all its employees to work from home.&nbsp; The company is responding to an urgent request from top management and needs to conduct a network stress test.&nbsp; This is done to make sure its network infrastructure is capable of providing sufficient bandwidth and to identify bottlenecks rapidly.&nbsp; Also executives request insight into network status and performance. They want to use NOM to capture the required metrics to validate the test, and stream the results to an executive business dashboard such as the one shown below:</p>

<p><img alt="" src="/mediawiki/images/pn_images/pn_image_5e8fb3c8048609.77267466.jpeg" style="height:281px; margin-bottom:0px; margin-left:0px; margin-right:0px; margin-top:0px; width:500px"></p>

<p><strong>Use Case Implementation:</strong> The use case&nbsp;was implemented in the following three steps:</p>

<ol>
	<li>Determine the metrics to be collected for the test,</li>
	<li>Configure NNMi to collect these new metrics,</li>
	<li>Use Micro Focus provided scripts to retrieve the collected metrics from NNMi NPS Server and stream them to a BVD dashboard.<br>
	(The scripts are included in the Appendix)</li>
</ol>

<p>Note:&nbsp; NNM iSPI Performance for Metrics and Network Performance Server (NPS) is required for this solution as all the metrics&nbsp;to be collected are performance data.&nbsp;</p>

<p>Details for each steps are described below:</p>

<p><strong>Step 1 - Determine the metrics to be collected </strong><br>
After some investigation of the devices, it was determined that the following metrics need to be collected to understand the devices’ current “stress level”:</p>

<ol>
	<li>The number of concurrent session on a company’s VPN Appliance. This number indicates how many employees are concurrently connected to the company’s VPN;</li>
	<li>CPU utilization of the router behind the VPN Appliance;</li>
	<li>Interface utilization of the router behind the VPN Appliance.</li>
</ol>

<p>The number of concurrent session is not part of NNMi’s standard polling metrics.&nbsp; After reviewing the SNMP MIB on the VPN Appliance (Cisco Adaptive Security Appliance Version 9.12(2)5), the MIB variable cfwConnectionStatValue.40.6 (OID:1.3.6.1.4.1.9.9.147.1.2.2.2.1.3.40.6) was found to contain the number of concurrent session needed.<br>
For devices other than this particular Cisco Security Appliance, proceed in a similar way: examine the device’s MIB, identify the MIB variable(s) that describe current device load or capacity, and take note of the corresponding OID(s).<br>
CPU and Interface utilizations are part of NNMi standard performance polling collection and don’t need to be configured through custom polling.<br>
<br>
<strong>Step 2 - Configure NNMi to collect the metrics</strong>&nbsp;<br>
The MIB variable identified in Step 1, cfwConnectionStatValue, is not part of NNMi’s standard (out-of-the-box) SNMP polling. &nbsp;NNMi provides a feature called “Custom Poller” which allows users to collect non-standard MIB variables.<br>
Create a custom poller “ConcurrentSessionPoller” as shown below:<br>
<br>
<img alt="https://docs.microfocus.com/mediawiki/images/pn_images/pn_image_5e7153f0193995.92249861.png" border="0" hspace="0" src="https://docs.microfocus.com/mediawiki/images/pn_images/pn_image_5e7153f0193995.92249861.png" style="border:0px solid black; height:358px; margin-bottom:0px; margin-left:0px; margin-right:0px; margin-top:0px; width:500px" vspace="0"><br>
<br>
(The details of creating a custom poller are not covered in this article.&nbsp; Instructions can be found <a href="https://docs.microfocus.com/NNMi/10.30/Content/Administer/nmAdminHelp/nmAdmConfCP0200CreateCPCol.htm">here</a>)<br>
This custom poller will be polling the number of concurrent session from the VPN Appliance every 5 minutes and store the data in the NPS server.<br>
To limit the impact of polling for CPU and Interface utilizations on all devices, create a node group “COVID-19” containing only those devices of interest for this use case: the VPN Appliances&nbsp;and the routers:<br>
<br>
<img alt="https://docs.microfocus.com/mediawiki/images/pn_images/pn_image_5e7153f042cf90.56002371.png" border="0" hspace="0" src="https://docs.microfocus.com/mediawiki/images/pn_images/pn_image_5e7153f042cf90.56002371.png" style="border:0px solid black; height:415px; margin-bottom:0px; margin-left:0px; margin-right:0px; margin-top:0px; width:500px" vspace="0"></p>

<p>Then enable the performance polling on the node group:<br>
<br>
<img alt="https://docs.microfocus.com/mediawiki/images/pn_images/pn_image_5e7155531df910.36331397.png" src="https://docs.microfocus.com/mediawiki/images/pn_images/pn_image_5e7155531df910.36331397.png" style="height:530px; width:698px"><br>
<br>
<strong>Step 3 - Use Micro Focus provided scripts to retrieve the collected metrics from NNMi NPS and stream them to BVD</strong><br>
As the title indicated, this article is mainly about streaming performance metrics from NNMi to BVD.&nbsp; Therefore this is the most important step.&nbsp;<br>
Micro Focus provided 2 scripts, sqlgenerator.ovpl and streambvd.sh, to facilitate the use case implementation.&nbsp; The scripts are attached in the Appendix.&nbsp; With the scripts, customers do not need to write complex SQL queries. By just specifying the extension pack and the metrics of interest, the sqlgenerator.ovpl&nbsp;will generate the appropriate SQL query.</p>

<p>Follow the instructions below to implement your custom solution:</p>

<ol>
	<li>Run the command “about.ovpl” on the NPS server.&nbsp; The command lists all the extension packs installed on the NPS.&nbsp;<br>
	Example:<br>
	<br>
	&nbsp;</li>
	<li>Choose an extension pack which contains the performance metrics of interest.&nbsp; For example, if you are interested in interface utilization metrics, choose the “Interface_Health” extension pack.<br>
	Run the script:<br>
	sqlgenerator.ovpl –p –a colgen<br>
	Example:<br>
	sqlgenerator.ovpl –p Interface_Health –a colgen<br>
	The script extracts all the metrics from the extension pack and saves them in a text file _dataColumns.config, for example, Interface_Health_dataColumns.config.</li>
	<li>Edit the _dataColumns.config&nbsp;file.&nbsp; Uncomment out the metrics of interest in the file then save the file.&nbsp;&nbsp; For example, if the metrics of interest are “Utilization (avg)”, “Utilization (max)” and “Utilization (min)”, remove the “#” from the beginning of the line, then save the file:</li>
	<li>Run the script:<br>
	sqlgenerator.ovpl –p –a sqlgen<br>
	Example:<br>
	sqlgenerator.ovpl –p Interface_Health –a sqlgen<br>
	In this step, the script will fetch all the metrics of interest specified in previous step, and generate a complex SQL query to retrieve the metrics from NPS server. &nbsp;The query will be saved in a text file with the name convention of _query.sql, for example:</li>
	<li>Run the script:<br>
	streamtobvd.sh –s -k -f<br>
	Where is the FQDN of the BVD server, is the BVD server’s API key (obtained from BVD Console), and is the name of the previously generated .sql query file.<br>
	Example:<br>
	streamtobvd.sh –s mybvd.microfocus.com –k fa4b8c37d69445c79695739c53e0ccd5 –f interfacemetrics_query.sql<br>
	<br>
	In this step, the script runs SQL query against NPS database, retrieve the metrics of interest, then format the metrics into a JSON message and stream it to the BVD server.&nbsp; A new data channel with these metrics will be available in BVD, as shown below:<br>
	<br>
	<br>
	Now, each performance metric in the new data channel can easily be associated with a particular widget in dashboard.</li>
</ol>

<p>Finally, we use a complete BVD dashboard example to conclude this article.<br>
<strong>Example – </strong>this example consisted of two BVD dashboards, a top-level executive dashboard and a drill-down dashboard showing more network performance data. &nbsp;The content of each dashboard is described as the following:</p>

<ol>
	<li>The top-level executive dashboard displays the company’s VPN architecture on the left panel.&nbsp;&nbsp;<br>
	The VPN is protected by a few VPN appliance servers (firewall servers) and a number of routers were deployed behind the VPN appliances.&nbsp; The right panel displays the time-series of the number of concurrent session on each VPN appliances.&nbsp;<br>
	The VPN appliance widgets or router widgets on the left panel can be configured to link to a drill-down dashboard.<br>
	<br>
	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</li>
	<li>The drill-down dashboard displays network performance metric data, such as interface and CPU utilization on VPN appliances and routers.&nbsp; This dashboard is of more interest to network engineers:</li>
</ol>

<p>Notes:<br>
a)&nbsp;As a prerequisite, NNMi and NA integration with BVD has to be configured.&nbsp; Instructions can be found&nbsp;<a href="https://docs.microfocus.com/itom/Network_Node_Manager_i:2019.11/NetworkDataBVD">here</a><br>
b)&nbsp;Both MF provided scripts need to run on the NPS server as it executes SQL queries to the NPS database.</p>

<p><strong>Summary</strong><br>
This article described the implementation of a solution to a user case which allow NOM customers to collect special MIB variables and performance metrics and stream the collected metrics to a BVD dashboard. &nbsp;This article also included 2 scripts for customers to facilitate the implementation of the solution.</p>

<p><strong>Appendix</strong><br>
Two scripts, &nbsp;sqlgenerator.ovpl and streamtobvd.sh for this solution are included in this section in their entirety.&nbsp;</p>

<p>sqlgenerator.ovpl:</p>

<p>#!/opt/OV/nonOV/perl/a/bin/perl -I/opt/OV/NNMPerformanceSPI/lib/perllibs/lib</p>

<p># NNM iSPI Performance</p>

<p># Purpose:</p>

<p>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To extract the data columns from a given extension pack and generate sql.</p>

<p>#</p>

<p>&nbsp;</p>

<p>use NPS::nps;</p>

<p>use DBI;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>loggername("Utility.sqlgenerator");</p>

<p>&nbsp;</p>

<p># Command line validations.</p>

<p>my %OPTS ;</p>

<p>showUsage() unless getopts("a:p:h", \%OPTS);</p>

<p>showUsage() unless (defined $OPTS{p});</p>

<p>&nbsp;</p>

<p>sub showUsage {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $usage = qq(Usage: sqlgenerator.ovpl [-h] -p -a sqlgen/colgen</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Display usage</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -p ExtensionPack&nbsp;&nbsp;&nbsp; Run against tables for named ExtensionPack</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -a colgen/sqlgen</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;NOTE :</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -p ExtensionPack Name should be the first argument</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colgen - to generate a list of data columns.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqlgen - to generate the sql, "-a colgen" should be run before "-a sqlgen"</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if -a is not provide default action chosen is "colgen"</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Use "PerfSPIProxyDSN" to run the generated sql</p>

<p>);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l10n_printf("%s", $usage);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit 0;</p>

<p>}</p>

<p>&nbsp;</p>

<p>#Reference Aggregations : avg, max, min, sum, cnt pctile05, pctile90, pctile95, pctile99</p>

<p>#Collected Aggregations.</p>

<p>#my $aggs_to_find = "avg";</p>

<p>my $aggs_to_find = "avg, min, max,";</p>

<p>my $catalog_table_prefix = "Column_Catalog_";</p>

<p>my $catalog_table_name = $catalog_table_prefix . $EXTENSIONPACK;</p>

<p>my $output_file_name = $EXTENSIONPACK . "_dataColumns" . ".config";</p>

<p>my $star_star = "***";</p>

<p>my $star = "*";</p>

<p>my $hash = "#";</p>

<p>my $col_delimiter = " | ";</p>

<p>my $conn = "DSN=$cfg{PRSPI_DB_DSN}" ;</p>

<p>&nbsp;</p>

<p>my $ifname_present = "" ; # ONLY used while sql generation.</p>

<p>&nbsp;</p>

<p># Connect to DB avoiding auto commit to preserve the table locks</p>

<p>my $dbh =</p>

<p>&nbsp; DBI-&gt;connect("dbi:SQLAnywhere:$conn;CON=sqlgenerator.OVPL PID=$$", "", "", { RaiseError =&gt; 0, AutoCommit =&gt; 0, PrintError =&gt; 1} ) ||</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; FATAL("Unable to connect to database: %s", $DBI::errstr);</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>sub getDataColumns {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $aggs_list = "";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach my $aggs (split(/,/,$aggs_to_find)) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $str = "'". trim($aggs) . "'";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if($aggs_list eq "") {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $aggs_list = $str;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $aggs_list = $aggs_list . "," . $str;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if($aggs_list eq "") {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INFO("Aggregations provided is empty, exiting");</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit 1;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $colSelectionSql = "SELECT MetricName FROM $catalog_table_name WHERE MetricDescrAggType in ($aggs_list) order by MetricName" ;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $colNames = $dbh-&gt;selectcol_arrayref($colSelectionSql) || FATAL ("Unable to get the columns names : %s",$DBI::errstr);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return @$colNames;</p>

<p>}</p>

<p>&nbsp;</p>

<p>sub getMetricName {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $metric_name_sql = "SELECT distinct MetricBlock FROM $catalog_table_name" ;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $metric_name = $dbh-&gt;selectrow_array($metric_name_sql) || FATAL ("Unable to get the metic block name: %s",$DBI::errstr);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $metric_name;</p>

<p>}</p>

<p>&nbsp;</p>

<p>sub persistToFile {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my ($metric_name, @colNames) = @_;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $cnt = 0;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(-e $output_file_name) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WARN("The file '%s' exists, all the modifications will be overwritten" , $output_file_name);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $file_handle = open_or_die("&gt;$output_file_name") ;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print $file_handle $star_star . "Data columns generated for the extension Pack :" . $EXTENSIONPACK . "\n";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print $file_handle $star_star . "ExtensionPack=". $EXTENSIONPACK . "\n";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print $file_handle $star_star . "MetricName=". $metric_name . "\n";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print $file_handle $star_star . "IMPORTANT STEPS : ". "\n";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print $file_handle $star_star . "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. Remove “#” from the beginning of the line to choose that particular column in the generated SQL.". "\n";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print $file_handle $star_star . "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. Run the script 'sqlgenerator.ovpl -p $EXTENSIONPACK -a sqlgen'". "\n\n";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach my $colName (@colNames) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++$cnt;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print $file_handle $hash.$colName."\n";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close $file_handle ;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INFO ("Query returned %s records for the extension pack %s" , $cnt, $EXTENSIONPACK);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( $cnt &gt; 0) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INFO ("IMPORTANT : \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Open the file '%s' and follow the instructions to generate the query" , $output_file_name);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WARN("Unable to generate the data columns");</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (-e $output_file_name) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unlink($output_file_name)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>}</p>

<p>&nbsp;</p>

<p>sub readFileAndGenerateColList {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(! -e $output_file_name) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WARN("Data columns is not generated for this extension pack ");</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit 1;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my @selected_columns ;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $metric_search_string = "MetricName=";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $metric_name = "";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $file_handle = open_or_die("&lt;$output_file_name") ;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $row_uncommented = 0;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (my $row = &lt;$file_handle&gt;) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chomp $row;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(($row ne "" ) &amp;&amp; !((index($row, $star_star) == 0) || index($row, $hash) == 0))&nbsp; {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # This row will be uncommented column name</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push (@selected_columns, $row) ;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++$row_uncommented ;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (($metric_name eq "") &amp;&amp; $row =~ m/$metric_search_string/) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #***MetricName=ComponentMetrics</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $equal_idx = index($row, "=");</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $metric_name = substr($row, $equal_idx + 1);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if($row_uncommented &lt; 1) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WARN("The file '%s' is not modified to pick the column list, modify the file and rerun the command" , $output_file_name);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit 1;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ($metric_name, @selected_columns);</p>

<p>}</p>

<p>&nbsp;</p>

<p>sub buildSelectHeader {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my ($virtual_table_name) = @_;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $header;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $group;</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #$virtual_table_name = "f_Virtual_InterfaceMetrics";&nbsp;&nbsp;&nbsp; # this is to test.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $ifname_column_to_check = 'Qualified Interface Name';</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $colSelectionSql = "SELECT column_name FROM sp_iqcolumn() WHERE table_name ='$virtual_table_name' and column_name = 'Qualified Interface Name'" ;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ifname_present = $dbh-&gt;selectrow_array($colSelectionSql);</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $header = "[Minute] [Minute | ], [Node Name] [Node Name | ]";&nbsp; # The header has | as the delimiter so that its easy for parsing in the script.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if($ifname_present eq "") {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $group = "[Minute], [Node Name]";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #$header = "[Minute], [Node Name], replace([Qualified Interface Name], ' ','-') [Qualified Interface Name]";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #Removing the [Qualified Interface Name] as requested by implementation.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $group&nbsp; = "[Minute], [Node Name], [Qualified Interface Name]";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ($header, $group);</p>

<p>}</p>

<p>&nbsp;</p>

<p>sub buildSelectFooter {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if($ifname_present ne "") {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return " , replace([Qualified Interface Name], ' ','-') [Qualified Interface Name | ] ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>}</p>

<p>&nbsp;</p>

<p>sub buildIntervalSql {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $interval = @_;&nbsp;&nbsp; # minutes</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $ret = "";</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if($interval == 5 ) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ret = " where [Minute] &gt; dateadd(second, -300, DATETIME(NOW())) ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } elsif ($interval == 10 ) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ret = " where [Minute] &gt; dateadd(second, -600, DATETIME(NOW())) ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } elsif ($interval == 60){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ret = " where [Minute] &gt; dateadd(second, -3600, DATETIME(NOW())) ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ret = " where [Minute] &gt; dateadd(second, -600, DATETIME(NOW())) ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $ret;</p>

<p>}</p>

<p>&nbsp;</p>

<p>sub getRange {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if($ifname_present eq "") {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "1, 2 ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "1, 2, 3 ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>}</p>

<p>&nbsp;</p>

<p>sub formatColumnNameForSelect {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my ($col_name) = @_;</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $sum_fn = "sum";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $count_fn = "count";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $div_oper = "/";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $open_param = "(";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $close_param = ")";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $open_braces = "[";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $close_braces = "]";</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##((sum([Column_name]) / count([Column_name]))) [Column_name]</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $col_name_header = $open_braces . $col_name . $col_delimiter . $close_braces;&nbsp; # -&gt; [Column_name | ]&nbsp; --&gt; | used as a delimiter to parse.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $temp_col_name = $open_braces . $col_name . $close_braces;&nbsp; # -&gt; [Column_name]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $temp_col_name_sum = $sum_fn. $open_param . $temp_col_name . $close_param ;&nbsp; # sum ("[Column_name]")</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $temp_col_name_cnt = $count_fn. $open_param . $temp_col_name . $close_param;&nbsp; # count ("[Column_name]")</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $final_col_strut = $open_param . $temp_col_name_sum . $div_oper . $temp_col_name_cnt . $close_param ;&nbsp; # Build equation (sum ("[Column_name]") / count ("[Column_name]"))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $final_col_strut =&nbsp; $final_col_strut . $col_name_header;&nbsp;&nbsp; #&nbsp; Added Header (sum ("[Column_name]") / count ("[Column_name]")) [Header]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $final_col_strut</p>

<p>}</p>

<p>&nbsp;</p>

<p>sub generateSql {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my ($metric_name, @colNamesLocal) = @_;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $virtual_table_name = fVirtualTableName($metric_name);</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $select = "select ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $comma = ", ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $group_by = " group by ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $order_by = " order by ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $from = " from ";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $double_quote = "\"";</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my ($select_header, $group_cols) = buildSelectHeader($virtual_table_name);</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $columns_for_sel = "";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach my $col_name (@colNamesLocal) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $formatted_col_name = formatColumnNameForSelect($col_name);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $columns_for_sel = $columns_for_sel . $comma . $formatted_col_name;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Add the footer columns if any.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $footer_cols = buildSelectFooter();</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $columns_for_sel = $columns_for_sel . $footer_cols;</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Add the from clause&nbsp; -- the virtual table</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $final_sql = $columns_for_sel . $from . $double_quote . $virtual_table_name . $double_quote;</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #Add where clause&nbsp; -- last 10 minutes</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $final_sql = $final_sql . buildIntervalSql(10);</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Add order by and group by</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $final_sql = $final_sql . $group_by . $group_cols;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #$final_sql = $final_sql . $order_by . $select_header . $columns_for_sel ;&nbsp;&nbsp; # convert to range</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $final_sql = $final_sql . $order_by . getRange() ;&nbsp;&nbsp; # convert to range</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Prepend select and select_header</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $final_sql = $select . $select_header . $final_sql;</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #Writing the sql to ouput file.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $sql_file_name = lc $metric_name . "_query.sql";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (-e $sql_file_name) {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $backup_file_name =&nbsp; $sql_file_name . "." . time;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "Renamed the existing SQL file " . $sql_file_name . " to " . $backup_file_name ."\n";</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy_or_warn("$sql_file_name","$backup_file_name") ;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $file_handle = open_or_die("&gt;$sql_file_name") ;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print $file_handle $final_sql;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close $file_handle;</p>

<p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #Instructions</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "Generated SQL is written to the file " . $sql_file_name . "\n";</p>

<p>}</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>my $action = $OPTS{a} || "colgen" ;&nbsp; # default action to generate data columns</p>

<p>&nbsp;</p>

<p>if ($action eq "colgen") {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #Generating the column list</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INFO("Generating data columns for the extension pack %s", $EXTENSIONPACK);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my @colNamesRet = getDataColumns();</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my $metric_name = getMetricName();</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; persistToFile($metric_name, @colNamesRet);</p>

<p>} elsif ($action eq "sqlgen") {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #For generating the sql</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my ($metric_name, @columns_for_sql) = readFileAndGenerateColList();</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; generateSql($metric_name, @columns_for_sql);</p>

<p>} else {</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INFO("Invalid Action");</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; showUsage();</p>

<p>}</p>

<p>&nbsp;</p>

<p>exit 0;</p>

<p>&nbsp;</p>

<p><br>
streamtobvd.sh<strong>:</strong></p>

<p>#!/bin/sh</p>

<p>usage(){</p>

<p>&nbsp; echo "Usage: $0 -s -k -f "</p>

<p>&nbsp; exit 1</p>

<p>}</p>

<p>[[ $# -lt 6 ]] &amp;&amp; usage</p>

<p>while [ "$1" != "" ]; do</p>

<p>case $1 in</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s ) &nbsp; shift</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BVDFQDN=$1</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -k )&nbsp;&nbsp;&nbsp; shift</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BVDAPIKEY=$1</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -f )&nbsp;&nbsp;&nbsp; shift</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQLFILE=$1</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * )&nbsp;&nbsp;&nbsp;&nbsp; usage</p>

<p>&nbsp;&nbsp;&nbsp; esac</p>

<p>&nbsp;&nbsp;&nbsp; shift</p>

<p>done</p>

<p>&nbsp;</p>

<p>BVDFQDN=$2</p>

<p>BVDAPIKEY=$4</p>

<p>SQLFILE=$6</p>

<p>BVDURL="https://$BVDFQDN/bvd-receiver/api/submit/"</p>

<p>BVDCURLURL="$BVDURL$BVDAPIKEY/dims/NodeName,PerfMetrics"</p>

<p>&nbsp;</p>

<p>FLAG=1</p>

<p>&nbsp;</p>

<p>while [ 1 ]</p>

<p>do</p>

<p>&nbsp;&nbsp;&nbsp; dbisql -nogui -c "DSN=PerfSPIProxyDSN" $SQLFILE | grep -v "NULL" | grep -v "Execution time" | grep -v "rows)" | while read line</p>

<p>&nbsp;&nbsp;&nbsp; do</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if [ $FLAG -eq 1 ]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLAG=0</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IFS='|'</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read -a metrics &lt;&lt;&lt; "$line"</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; metriclen=${#metrics[@]}</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (( k=0; k&lt;$metriclen; k++ ))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; metrics[$k]=`echo -e "${metrics[$k]}" | sed 's/^[ \t]*//;s/[ \t]*$//'`</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; done</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IFS=' '</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line=`echo $line | sed -e '/^\s*$/d' -e '/^-/d'`</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if [ ! -z "$line" ]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arr=($line)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len=${#arr[@]}</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NODENAME=${arr[2]}</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JSONMSG='{"NodeName":"'$NODENAME'","PerfMetrics":"My Metrics",'</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (( c=3; c&lt;$len; c++ ))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=$[$c-1]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name=${metrics[$i]}</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if [ $c -lt $[len-1] ]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; element="\""${name}"\"":"\""${arr[$c]}"\"",</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; element="\""${name}"\"":"\""${arr[$c]}"\""</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo $element</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JSONMSG=${JSONMSG}$element</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; done</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JSONMSG=${JSONMSG}"}"</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curl -k -X POST -H "Content-Type:application/json" -d "$JSONMSG" $BVDCURLURL</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo ""</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi</p>

<p>&nbsp;&nbsp;&nbsp; done</p>

<p>&nbsp;&nbsp;&nbsp; sleep 300</p>

<p>done</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>​</p>
